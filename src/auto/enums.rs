// This file was generated by gir (ce03df6) from gir-files (71d73f0)
// DO NOT EDIT

use ffi;
use glib_ffi;
use glib::error::ErrorDomain;
use glib::translate::*;
use std;

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Align {
    Fill,
    Start,
    End,
    Center,
    Baseline,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for Align {
    type GlibType = ffi::GtkAlign;

    fn to_glib(&self) -> ffi::GtkAlign {
        match *self {
            Align::Fill => ffi::GTK_ALIGN_FILL,
            Align::Start => ffi::GTK_ALIGN_START,
            Align::End => ffi::GTK_ALIGN_END,
            Align::Center => ffi::GTK_ALIGN_CENTER,
            Align::Baseline => ffi::GTK_ALIGN_BASELINE,
            Align::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAlign> for Align {
    fn from_glib(value: ffi::GtkAlign) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => Align::Fill,
            1 => Align::Start,
            2 => Align::End,
            3 => Align::Center,
            4 => Align::Baseline,
            value => Align::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ArrowType {
    Up,
    Down,
    Left,
    Right,
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ArrowType {
    type GlibType = ffi::GtkArrowType;

    fn to_glib(&self) -> ffi::GtkArrowType {
        match *self {
            ArrowType::Up => ffi::GTK_ARROW_UP,
            ArrowType::Down => ffi::GTK_ARROW_DOWN,
            ArrowType::Left => ffi::GTK_ARROW_LEFT,
            ArrowType::Right => ffi::GTK_ARROW_RIGHT,
            ArrowType::None => ffi::GTK_ARROW_NONE,
            ArrowType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkArrowType> for ArrowType {
    fn from_glib(value: ffi::GtkArrowType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ArrowType::Up,
            1 => ArrowType::Down,
            2 => ArrowType::Left,
            3 => ArrowType::Right,
            4 => ArrowType::None,
            value => ArrowType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum AssistantPageType {
    Content,
    Intro,
    Confirm,
    Summary,
    Progress,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for AssistantPageType {
    type GlibType = ffi::GtkAssistantPageType;

    fn to_glib(&self) -> ffi::GtkAssistantPageType {
        match *self {
            AssistantPageType::Content => ffi::GTK_ASSISTANT_PAGE_CONTENT,
            AssistantPageType::Intro => ffi::GTK_ASSISTANT_PAGE_INTRO,
            AssistantPageType::Confirm => ffi::GTK_ASSISTANT_PAGE_CONFIRM,
            AssistantPageType::Summary => ffi::GTK_ASSISTANT_PAGE_SUMMARY,
            AssistantPageType::Progress => ffi::GTK_ASSISTANT_PAGE_PROGRESS,
            AssistantPageType::Custom => ffi::GTK_ASSISTANT_PAGE_CUSTOM,
            AssistantPageType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAssistantPageType> for AssistantPageType {
    fn from_glib(value: ffi::GtkAssistantPageType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => AssistantPageType::Content,
            1 => AssistantPageType::Intro,
            2 => AssistantPageType::Confirm,
            3 => AssistantPageType::Summary,
            4 => AssistantPageType::Progress,
            5 => AssistantPageType::Custom,
            value => AssistantPageType::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_10")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum BaselinePosition {
    Top,
    Center,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_10")]
#[doc(hidden)]
impl ToGlib for BaselinePosition {
    type GlibType = ffi::GtkBaselinePosition;

    fn to_glib(&self) -> ffi::GtkBaselinePosition {
        match *self {
            BaselinePosition::Top => ffi::GTK_BASELINE_POSITION_TOP,
            BaselinePosition::Center => ffi::GTK_BASELINE_POSITION_CENTER,
            BaselinePosition::Bottom => ffi::GTK_BASELINE_POSITION_BOTTOM,
            BaselinePosition::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_10")]
#[doc(hidden)]
impl FromGlib<ffi::GtkBaselinePosition> for BaselinePosition {
    fn from_glib(value: ffi::GtkBaselinePosition) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => BaselinePosition::Top,
            1 => BaselinePosition::Center,
            2 => BaselinePosition::Bottom,
            value => BaselinePosition::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum BuilderError {
    InvalidTypeFunction,
    UnhandledTag,
    MissingAttribute,
    InvalidAttribute,
    InvalidTag,
    MissingPropertyValue,
    InvalidValue,
    VersionMismatch,
    DuplicateId,
    ObjectTypeRefused,
    TemplateMismatch,
    InvalidProperty,
    InvalidSignal,
    InvalidId,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for BuilderError {
    type GlibType = ffi::GtkBuilderError;

    fn to_glib(&self) -> ffi::GtkBuilderError {
        match *self {
            BuilderError::InvalidTypeFunction => ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION,
            BuilderError::UnhandledTag => ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG,
            BuilderError::MissingAttribute => ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE,
            BuilderError::InvalidAttribute => ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE,
            BuilderError::InvalidTag => ffi::GTK_BUILDER_ERROR_INVALID_TAG,
            BuilderError::MissingPropertyValue => ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE,
            BuilderError::InvalidValue => ffi::GTK_BUILDER_ERROR_INVALID_VALUE,
            BuilderError::VersionMismatch => ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH,
            BuilderError::DuplicateId => ffi::GTK_BUILDER_ERROR_DUPLICATE_ID,
            BuilderError::ObjectTypeRefused => ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED,
            BuilderError::TemplateMismatch => ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH,
            BuilderError::InvalidProperty => ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY,
            BuilderError::InvalidSignal => ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL,
            BuilderError::InvalidId => ffi::GTK_BUILDER_ERROR_INVALID_ID,
            BuilderError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBuilderError> for BuilderError {
    fn from_glib(value: ffi::GtkBuilderError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => BuilderError::InvalidTypeFunction,
            1 => BuilderError::UnhandledTag,
            2 => BuilderError::MissingAttribute,
            3 => BuilderError::InvalidAttribute,
            4 => BuilderError::InvalidTag,
            5 => BuilderError::MissingPropertyValue,
            6 => BuilderError::InvalidValue,
            7 => BuilderError::VersionMismatch,
            8 => BuilderError::DuplicateId,
            9 => BuilderError::ObjectTypeRefused,
            10 => BuilderError::TemplateMismatch,
            11 => BuilderError::InvalidProperty,
            12 => BuilderError::InvalidSignal,
            13 => BuilderError::InvalidId,
            value => BuilderError::__Unknown(value),
        }
    }
}

impl ErrorDomain for BuilderError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_builder_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(BuilderError::InvalidTypeFunction),
            1 => Some(BuilderError::UnhandledTag),
            2 => Some(BuilderError::MissingAttribute),
            3 => Some(BuilderError::InvalidAttribute),
            4 => Some(BuilderError::InvalidTag),
            5 => Some(BuilderError::MissingPropertyValue),
            6 => Some(BuilderError::InvalidValue),
            7 => Some(BuilderError::VersionMismatch),
            8 => Some(BuilderError::DuplicateId),
            9 => Some(BuilderError::ObjectTypeRefused),
            10 => Some(BuilderError::TemplateMismatch),
            11 => Some(BuilderError::InvalidProperty),
            12 => Some(BuilderError::InvalidSignal),
            13 => Some(BuilderError::InvalidId),
            value => Some(BuilderError::__Unknown(value)),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ButtonBoxStyle {
    Spread,
    Edge,
    Start,
    End,
    Center,
    Expand,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ButtonBoxStyle {
    type GlibType = ffi::GtkButtonBoxStyle;

    fn to_glib(&self) -> ffi::GtkButtonBoxStyle {
        match *self {
            ButtonBoxStyle::Spread => ffi::GTK_BUTTONBOX_SPREAD,
            ButtonBoxStyle::Edge => ffi::GTK_BUTTONBOX_EDGE,
            ButtonBoxStyle::Start => ffi::GTK_BUTTONBOX_START,
            ButtonBoxStyle::End => ffi::GTK_BUTTONBOX_END,
            ButtonBoxStyle::Center => ffi::GTK_BUTTONBOX_CENTER,
            ButtonBoxStyle::Expand => ffi::GTK_BUTTONBOX_EXPAND,
            ButtonBoxStyle::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonBoxStyle> for ButtonBoxStyle {
    fn from_glib(value: ffi::GtkButtonBoxStyle) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            1 => ButtonBoxStyle::Spread,
            2 => ButtonBoxStyle::Edge,
            3 => ButtonBoxStyle::Start,
            4 => ButtonBoxStyle::End,
            5 => ButtonBoxStyle::Center,
            6 => ButtonBoxStyle::Expand,
            value => ButtonBoxStyle::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ButtonRole {
    Normal,
    Check,
    Radio,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ButtonRole {
    type GlibType = ffi::GtkButtonRole;

    fn to_glib(&self) -> ffi::GtkButtonRole {
        match *self {
            ButtonRole::Normal => ffi::GTK_BUTTON_ROLE_NORMAL,
            ButtonRole::Check => ffi::GTK_BUTTON_ROLE_CHECK,
            ButtonRole::Radio => ffi::GTK_BUTTON_ROLE_RADIO,
            ButtonRole::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonRole> for ButtonRole {
    fn from_glib(value: ffi::GtkButtonRole) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ButtonRole::Normal,
            1 => ButtonRole::Check,
            2 => ButtonRole::Radio,
            value => ButtonRole::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ButtonsType {
    None,
    Ok,
    Close,
    Cancel,
    YesNo,
    OkCancel,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ButtonsType {
    type GlibType = ffi::GtkButtonsType;

    fn to_glib(&self) -> ffi::GtkButtonsType {
        match *self {
            ButtonsType::None => ffi::GTK_BUTTONS_NONE,
            ButtonsType::Ok => ffi::GTK_BUTTONS_OK,
            ButtonsType::Close => ffi::GTK_BUTTONS_CLOSE,
            ButtonsType::Cancel => ffi::GTK_BUTTONS_CANCEL,
            ButtonsType::YesNo => ffi::GTK_BUTTONS_YES_NO,
            ButtonsType::OkCancel => ffi::GTK_BUTTONS_OK_CANCEL,
            ButtonsType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonsType> for ButtonsType {
    fn from_glib(value: ffi::GtkButtonsType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ButtonsType::None,
            1 => ButtonsType::Ok,
            2 => ButtonsType::Close,
            3 => ButtonsType::Cancel,
            4 => ButtonsType::YesNo,
            5 => ButtonsType::OkCancel,
            value => ButtonsType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CellRendererAccelMode {
    Gtk,
    Other,
    ModifierTap,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CellRendererAccelMode {
    type GlibType = ffi::GtkCellRendererAccelMode;

    fn to_glib(&self) -> ffi::GtkCellRendererAccelMode {
        match *self {
            CellRendererAccelMode::Gtk => ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK,
            CellRendererAccelMode::Other => ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
            CellRendererAccelMode::ModifierTap => ffi::GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP,
            CellRendererAccelMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererAccelMode> for CellRendererAccelMode {
    fn from_glib(value: ffi::GtkCellRendererAccelMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => CellRendererAccelMode::Gtk,
            1 => CellRendererAccelMode::Other,
            2 => CellRendererAccelMode::ModifierTap,
            value => CellRendererAccelMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CellRendererMode {
    Inert,
    Activatable,
    Editable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CellRendererMode {
    type GlibType = ffi::GtkCellRendererMode;

    fn to_glib(&self) -> ffi::GtkCellRendererMode {
        match *self {
            CellRendererMode::Inert => ffi::GTK_CELL_RENDERER_MODE_INERT,
            CellRendererMode::Activatable => ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE,
            CellRendererMode::Editable => ffi::GTK_CELL_RENDERER_MODE_EDITABLE,
            CellRendererMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererMode> for CellRendererMode {
    fn from_glib(value: ffi::GtkCellRendererMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => CellRendererMode::Inert,
            1 => CellRendererMode::Activatable,
            2 => CellRendererMode::Editable,
            value => CellRendererMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CornerType {
    TopLeft,
    BottomLeft,
    TopRight,
    BottomRight,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CornerType {
    type GlibType = ffi::GtkCornerType;

    fn to_glib(&self) -> ffi::GtkCornerType {
        match *self {
            CornerType::TopLeft => ffi::GTK_CORNER_TOP_LEFT,
            CornerType::BottomLeft => ffi::GTK_CORNER_BOTTOM_LEFT,
            CornerType::TopRight => ffi::GTK_CORNER_TOP_RIGHT,
            CornerType::BottomRight => ffi::GTK_CORNER_BOTTOM_RIGHT,
            CornerType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCornerType> for CornerType {
    fn from_glib(value: ffi::GtkCornerType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => CornerType::TopLeft,
            1 => CornerType::BottomLeft,
            2 => CornerType::TopRight,
            3 => CornerType::BottomRight,
            value => CornerType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CssProviderError {
    Failed,
    Syntax,
    Import,
    Name,
    Deprecated,
    UnknownValue,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CssProviderError {
    type GlibType = ffi::GtkCssProviderError;

    fn to_glib(&self) -> ffi::GtkCssProviderError {
        match *self {
            CssProviderError::Failed => ffi::GTK_CSS_PROVIDER_ERROR_FAILED,
            CssProviderError::Syntax => ffi::GTK_CSS_PROVIDER_ERROR_SYNTAX,
            CssProviderError::Import => ffi::GTK_CSS_PROVIDER_ERROR_IMPORT,
            CssProviderError::Name => ffi::GTK_CSS_PROVIDER_ERROR_NAME,
            CssProviderError::Deprecated => ffi::GTK_CSS_PROVIDER_ERROR_DEPRECATED,
            CssProviderError::UnknownValue => ffi::GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE,
            CssProviderError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssProviderError> for CssProviderError {
    fn from_glib(value: ffi::GtkCssProviderError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => CssProviderError::Failed,
            1 => CssProviderError::Syntax,
            2 => CssProviderError::Import,
            3 => CssProviderError::Name,
            4 => CssProviderError::Deprecated,
            5 => CssProviderError::UnknownValue,
            value => CssProviderError::__Unknown(value),
        }
    }
}

impl ErrorDomain for CssProviderError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_css_provider_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(CssProviderError::Failed),
            1 => Some(CssProviderError::Syntax),
            2 => Some(CssProviderError::Import),
            3 => Some(CssProviderError::Name),
            4 => Some(CssProviderError::Deprecated),
            5 => Some(CssProviderError::UnknownValue),
            _ => Some(CssProviderError::Failed),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CssSectionType {
    Document,
    Import,
    ColorDefinition,
    BindingSet,
    Ruleset,
    Selector,
    Declaration,
    Value,
    Keyframes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CssSectionType {
    type GlibType = ffi::GtkCssSectionType;

    fn to_glib(&self) -> ffi::GtkCssSectionType {
        match *self {
            CssSectionType::Document => ffi::GTK_CSS_SECTION_DOCUMENT,
            CssSectionType::Import => ffi::GTK_CSS_SECTION_IMPORT,
            CssSectionType::ColorDefinition => ffi::GTK_CSS_SECTION_COLOR_DEFINITION,
            CssSectionType::BindingSet => ffi::GTK_CSS_SECTION_BINDING_SET,
            CssSectionType::Ruleset => ffi::GTK_CSS_SECTION_RULESET,
            CssSectionType::Selector => ffi::GTK_CSS_SECTION_SELECTOR,
            CssSectionType::Declaration => ffi::GTK_CSS_SECTION_DECLARATION,
            CssSectionType::Value => ffi::GTK_CSS_SECTION_VALUE,
            CssSectionType::Keyframes => ffi::GTK_CSS_SECTION_KEYFRAMES,
            CssSectionType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssSectionType> for CssSectionType {
    fn from_glib(value: ffi::GtkCssSectionType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => CssSectionType::Document,
            1 => CssSectionType::Import,
            2 => CssSectionType::ColorDefinition,
            3 => CssSectionType::BindingSet,
            4 => CssSectionType::Ruleset,
            5 => CssSectionType::Selector,
            6 => CssSectionType::Declaration,
            7 => CssSectionType::Value,
            8 => CssSectionType::Keyframes,
            value => CssSectionType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DeleteType {
    Chars,
    WordEnds,
    Words,
    DisplayLines,
    DisplayLineEnds,
    ParagraphEnds,
    Paragraphs,
    Whitespace,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DeleteType {
    type GlibType = ffi::GtkDeleteType;

    fn to_glib(&self) -> ffi::GtkDeleteType {
        match *self {
            DeleteType::Chars => ffi::GTK_DELETE_CHARS,
            DeleteType::WordEnds => ffi::GTK_DELETE_WORD_ENDS,
            DeleteType::Words => ffi::GTK_DELETE_WORDS,
            DeleteType::DisplayLines => ffi::GTK_DELETE_DISPLAY_LINES,
            DeleteType::DisplayLineEnds => ffi::GTK_DELETE_DISPLAY_LINE_ENDS,
            DeleteType::ParagraphEnds => ffi::GTK_DELETE_PARAGRAPH_ENDS,
            DeleteType::Paragraphs => ffi::GTK_DELETE_PARAGRAPHS,
            DeleteType::Whitespace => ffi::GTK_DELETE_WHITESPACE,
            DeleteType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDeleteType> for DeleteType {
    fn from_glib(value: ffi::GtkDeleteType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => DeleteType::Chars,
            1 => DeleteType::WordEnds,
            2 => DeleteType::Words,
            3 => DeleteType::DisplayLines,
            4 => DeleteType::DisplayLineEnds,
            5 => DeleteType::ParagraphEnds,
            6 => DeleteType::Paragraphs,
            7 => DeleteType::Whitespace,
            value => DeleteType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DirectionType {
    TabForward,
    TabBackward,
    Up,
    Down,
    Left,
    Right,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DirectionType {
    type GlibType = ffi::GtkDirectionType;

    fn to_glib(&self) -> ffi::GtkDirectionType {
        match *self {
            DirectionType::TabForward => ffi::GTK_DIR_TAB_FORWARD,
            DirectionType::TabBackward => ffi::GTK_DIR_TAB_BACKWARD,
            DirectionType::Up => ffi::GTK_DIR_UP,
            DirectionType::Down => ffi::GTK_DIR_DOWN,
            DirectionType::Left => ffi::GTK_DIR_LEFT,
            DirectionType::Right => ffi::GTK_DIR_RIGHT,
            DirectionType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDirectionType> for DirectionType {
    fn from_glib(value: ffi::GtkDirectionType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => DirectionType::TabForward,
            1 => DirectionType::TabBackward,
            2 => DirectionType::Up,
            3 => DirectionType::Down,
            4 => DirectionType::Left,
            5 => DirectionType::Right,
            value => DirectionType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DragResult {
    Success,
    NoTarget,
    UserCancelled,
    TimeoutExpired,
    GrabBroken,
    Error,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DragResult {
    type GlibType = ffi::GtkDragResult;

    fn to_glib(&self) -> ffi::GtkDragResult {
        match *self {
            DragResult::Success => ffi::GTK_DRAG_RESULT_SUCCESS,
            DragResult::NoTarget => ffi::GTK_DRAG_RESULT_NO_TARGET,
            DragResult::UserCancelled => ffi::GTK_DRAG_RESULT_USER_CANCELLED,
            DragResult::TimeoutExpired => ffi::GTK_DRAG_RESULT_TIMEOUT_EXPIRED,
            DragResult::GrabBroken => ffi::GTK_DRAG_RESULT_GRAB_BROKEN,
            DragResult::Error => ffi::GTK_DRAG_RESULT_ERROR,
            DragResult::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDragResult> for DragResult {
    fn from_glib(value: ffi::GtkDragResult) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => DragResult::Success,
            1 => DragResult::NoTarget,
            2 => DragResult::UserCancelled,
            3 => DragResult::TimeoutExpired,
            4 => DragResult::GrabBroken,
            5 => DragResult::Error,
            value => DragResult::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum EntryIconPosition {
    Primary,
    Secondary,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for EntryIconPosition {
    type GlibType = ffi::GtkEntryIconPosition;

    fn to_glib(&self) -> ffi::GtkEntryIconPosition {
        match *self {
            EntryIconPosition::Primary => ffi::GTK_ENTRY_ICON_PRIMARY,
            EntryIconPosition::Secondary => ffi::GTK_ENTRY_ICON_SECONDARY,
            EntryIconPosition::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEntryIconPosition> for EntryIconPosition {
    fn from_glib(value: ffi::GtkEntryIconPosition) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => EntryIconPosition::Primary,
            1 => EntryIconPosition::Secondary,
            value => EntryIconPosition::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_14")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum EventSequenceState {
    None,
    Claimed,
    Denied,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl ToGlib for EventSequenceState {
    type GlibType = ffi::GtkEventSequenceState;

    fn to_glib(&self) -> ffi::GtkEventSequenceState {
        match *self {
            EventSequenceState::None => ffi::GTK_EVENT_SEQUENCE_NONE,
            EventSequenceState::Claimed => ffi::GTK_EVENT_SEQUENCE_CLAIMED,
            EventSequenceState::Denied => ffi::GTK_EVENT_SEQUENCE_DENIED,
            EventSequenceState::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl FromGlib<ffi::GtkEventSequenceState> for EventSequenceState {
    fn from_glib(value: ffi::GtkEventSequenceState) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => EventSequenceState::None,
            1 => EventSequenceState::Claimed,
            2 => EventSequenceState::Denied,
            value => EventSequenceState::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileChooserAction {
    Open,
    Save,
    SelectFolder,
    CreateFolder,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for FileChooserAction {
    type GlibType = ffi::GtkFileChooserAction;

    fn to_glib(&self) -> ffi::GtkFileChooserAction {
        match *self {
            FileChooserAction::Open => ffi::GTK_FILE_CHOOSER_ACTION_OPEN,
            FileChooserAction::Save => ffi::GTK_FILE_CHOOSER_ACTION_SAVE,
            FileChooserAction::SelectFolder => ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
            FileChooserAction::CreateFolder => ffi::GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER,
            FileChooserAction::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserAction> for FileChooserAction {
    fn from_glib(value: ffi::GtkFileChooserAction) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => FileChooserAction::Open,
            1 => FileChooserAction::Save,
            2 => FileChooserAction::SelectFolder,
            3 => FileChooserAction::CreateFolder,
            value => FileChooserAction::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileChooserConfirmation {
    Confirm,
    AcceptFilename,
    SelectAgain,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for FileChooserConfirmation {
    type GlibType = ffi::GtkFileChooserConfirmation;

    fn to_glib(&self) -> ffi::GtkFileChooserConfirmation {
        match *self {
            FileChooserConfirmation::Confirm => ffi::GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM,
            FileChooserConfirmation::AcceptFilename => ffi::GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME,
            FileChooserConfirmation::SelectAgain => ffi::GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN,
            FileChooserConfirmation::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserConfirmation> for FileChooserConfirmation {
    fn from_glib(value: ffi::GtkFileChooserConfirmation) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => FileChooserConfirmation::Confirm,
            1 => FileChooserConfirmation::AcceptFilename,
            2 => FileChooserConfirmation::SelectAgain,
            value => FileChooserConfirmation::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileChooserError {
    Nonexistent,
    BadFilename,
    AlreadyExists,
    IncompleteHostname,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for FileChooserError {
    type GlibType = ffi::GtkFileChooserError;

    fn to_glib(&self) -> ffi::GtkFileChooserError {
        match *self {
            FileChooserError::Nonexistent => ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT,
            FileChooserError::BadFilename => ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME,
            FileChooserError::AlreadyExists => ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS,
            FileChooserError::IncompleteHostname => ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME,
            FileChooserError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserError> for FileChooserError {
    fn from_glib(value: ffi::GtkFileChooserError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => FileChooserError::Nonexistent,
            1 => FileChooserError::BadFilename,
            2 => FileChooserError::AlreadyExists,
            3 => FileChooserError::IncompleteHostname,
            value => FileChooserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FileChooserError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_file_chooser_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FileChooserError::Nonexistent),
            1 => Some(FileChooserError::BadFilename),
            2 => Some(FileChooserError::AlreadyExists),
            3 => Some(FileChooserError::IncompleteHostname),
            value => Some(FileChooserError::__Unknown(value)),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IMPreeditStyle {
    Nothing,
    Callback,
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IMPreeditStyle {
    type GlibType = ffi::GtkIMPreeditStyle;

    fn to_glib(&self) -> ffi::GtkIMPreeditStyle {
        match *self {
            IMPreeditStyle::Nothing => ffi::GTK_IM_PREEDIT_NOTHING,
            IMPreeditStyle::Callback => ffi::GTK_IM_PREEDIT_CALLBACK,
            IMPreeditStyle::None => ffi::GTK_IM_PREEDIT_NONE,
            IMPreeditStyle::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIMPreeditStyle> for IMPreeditStyle {
    fn from_glib(value: ffi::GtkIMPreeditStyle) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => IMPreeditStyle::Nothing,
            1 => IMPreeditStyle::Callback,
            2 => IMPreeditStyle::None,
            value => IMPreeditStyle::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IMStatusStyle {
    Nothing,
    Callback,
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IMStatusStyle {
    type GlibType = ffi::GtkIMStatusStyle;

    fn to_glib(&self) -> ffi::GtkIMStatusStyle {
        match *self {
            IMStatusStyle::Nothing => ffi::GTK_IM_STATUS_NOTHING,
            IMStatusStyle::Callback => ffi::GTK_IM_STATUS_CALLBACK,
            IMStatusStyle::None => ffi::GTK_IM_STATUS_NONE,
            IMStatusStyle::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIMStatusStyle> for IMStatusStyle {
    fn from_glib(value: ffi::GtkIMStatusStyle) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => IMStatusStyle::Nothing,
            1 => IMStatusStyle::Callback,
            2 => IMStatusStyle::None,
            value => IMStatusStyle::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IconSize {
    Invalid,
    Menu,
    SmallToolbar,
    LargeToolbar,
    Button,
    Dnd,
    Dialog,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IconSize {
    type GlibType = ffi::GtkIconSize;

    fn to_glib(&self) -> ffi::GtkIconSize {
        match *self {
            IconSize::Invalid => ffi::GTK_ICON_SIZE_INVALID,
            IconSize::Menu => ffi::GTK_ICON_SIZE_MENU,
            IconSize::SmallToolbar => ffi::GTK_ICON_SIZE_SMALL_TOOLBAR,
            IconSize::LargeToolbar => ffi::GTK_ICON_SIZE_LARGE_TOOLBAR,
            IconSize::Button => ffi::GTK_ICON_SIZE_BUTTON,
            IconSize::Dnd => ffi::GTK_ICON_SIZE_DND,
            IconSize::Dialog => ffi::GTK_ICON_SIZE_DIALOG,
            IconSize::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconSize> for IconSize {
    fn from_glib(value: ffi::GtkIconSize) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => IconSize::Invalid,
            1 => IconSize::Menu,
            2 => IconSize::SmallToolbar,
            3 => IconSize::LargeToolbar,
            4 => IconSize::Button,
            5 => IconSize::Dnd,
            6 => IconSize::Dialog,
            value => IconSize::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IconThemeError {
    NotFound,
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IconThemeError {
    type GlibType = ffi::GtkIconThemeError;

    fn to_glib(&self) -> ffi::GtkIconThemeError {
        match *self {
            IconThemeError::NotFound => ffi::GTK_ICON_THEME_NOT_FOUND,
            IconThemeError::Failed => ffi::GTK_ICON_THEME_FAILED,
            IconThemeError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconThemeError> for IconThemeError {
    fn from_glib(value: ffi::GtkIconThemeError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => IconThemeError::NotFound,
            1 => IconThemeError::Failed,
            value => IconThemeError::__Unknown(value),
        }
    }
}

impl ErrorDomain for IconThemeError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_icon_theme_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(IconThemeError::NotFound),
            1 => Some(IconThemeError::Failed),
            _ => Some(IconThemeError::Failed),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IconViewDropPosition {
    NoDrop,
    DropInto,
    DropLeft,
    DropRight,
    DropAbove,
    DropBelow,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IconViewDropPosition {
    type GlibType = ffi::GtkIconViewDropPosition;

    fn to_glib(&self) -> ffi::GtkIconViewDropPosition {
        match *self {
            IconViewDropPosition::NoDrop => ffi::GTK_ICON_VIEW_NO_DROP,
            IconViewDropPosition::DropInto => ffi::GTK_ICON_VIEW_DROP_INTO,
            IconViewDropPosition::DropLeft => ffi::GTK_ICON_VIEW_DROP_LEFT,
            IconViewDropPosition::DropRight => ffi::GTK_ICON_VIEW_DROP_RIGHT,
            IconViewDropPosition::DropAbove => ffi::GTK_ICON_VIEW_DROP_ABOVE,
            IconViewDropPosition::DropBelow => ffi::GTK_ICON_VIEW_DROP_BELOW,
            IconViewDropPosition::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconViewDropPosition> for IconViewDropPosition {
    fn from_glib(value: ffi::GtkIconViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => IconViewDropPosition::NoDrop,
            1 => IconViewDropPosition::DropInto,
            2 => IconViewDropPosition::DropLeft,
            3 => IconViewDropPosition::DropRight,
            4 => IconViewDropPosition::DropAbove,
            5 => IconViewDropPosition::DropBelow,
            value => IconViewDropPosition::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ImageType {
    Empty,
    Pixbuf,
    Stock,
    IconSet,
    Animation,
    IconName,
    Gicon,
    Surface,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ImageType {
    type GlibType = ffi::GtkImageType;

    fn to_glib(&self) -> ffi::GtkImageType {
        match *self {
            ImageType::Empty => ffi::GTK_IMAGE_EMPTY,
            ImageType::Pixbuf => ffi::GTK_IMAGE_PIXBUF,
            ImageType::Stock => ffi::GTK_IMAGE_STOCK,
            ImageType::IconSet => ffi::GTK_IMAGE_ICON_SET,
            ImageType::Animation => ffi::GTK_IMAGE_ANIMATION,
            ImageType::IconName => ffi::GTK_IMAGE_ICON_NAME,
            ImageType::Gicon => ffi::GTK_IMAGE_GICON,
            ImageType::Surface => ffi::GTK_IMAGE_SURFACE,
            ImageType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkImageType> for ImageType {
    fn from_glib(value: ffi::GtkImageType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ImageType::Empty,
            1 => ImageType::Pixbuf,
            2 => ImageType::Stock,
            3 => ImageType::IconSet,
            4 => ImageType::Animation,
            5 => ImageType::IconName,
            6 => ImageType::Gicon,
            7 => ImageType::Surface,
            value => ImageType::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_6")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum InputPurpose {
    FreeForm,
    Alpha,
    Digits,
    Number,
    Phone,
    Url,
    Email,
    Name,
    Password,
    Pin,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = ffi::GtkInputPurpose;

    fn to_glib(&self) -> ffi::GtkInputPurpose {
        match *self {
            InputPurpose::FreeForm => ffi::GTK_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Alpha => ffi::GTK_INPUT_PURPOSE_ALPHA,
            InputPurpose::Digits => ffi::GTK_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => ffi::GTK_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => ffi::GTK_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => ffi::GTK_INPUT_PURPOSE_URL,
            InputPurpose::Email => ffi::GTK_INPUT_PURPOSE_EMAIL,
            InputPurpose::Name => ffi::GTK_INPUT_PURPOSE_NAME,
            InputPurpose::Password => ffi::GTK_INPUT_PURPOSE_PASSWORD,
            InputPurpose::Pin => ffi::GTK_INPUT_PURPOSE_PIN,
            InputPurpose::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl FromGlib<ffi::GtkInputPurpose> for InputPurpose {
    fn from_glib(value: ffi::GtkInputPurpose) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => InputPurpose::FreeForm,
            1 => InputPurpose::Alpha,
            2 => InputPurpose::Digits,
            3 => InputPurpose::Number,
            4 => InputPurpose::Phone,
            5 => InputPurpose::Url,
            6 => InputPurpose::Email,
            7 => InputPurpose::Name,
            8 => InputPurpose::Password,
            9 => InputPurpose::Pin,
            value => InputPurpose::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Justification {
    Left,
    Right,
    Center,
    Fill,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for Justification {
    type GlibType = ffi::GtkJustification;

    fn to_glib(&self) -> ffi::GtkJustification {
        match *self {
            Justification::Left => ffi::GTK_JUSTIFY_LEFT,
            Justification::Right => ffi::GTK_JUSTIFY_RIGHT,
            Justification::Center => ffi::GTK_JUSTIFY_CENTER,
            Justification::Fill => ffi::GTK_JUSTIFY_FILL,
            Justification::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkJustification> for Justification {
    fn from_glib(value: ffi::GtkJustification) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => Justification::Left,
            1 => Justification::Right,
            2 => Justification::Center,
            3 => Justification::Fill,
            value => Justification::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_6")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum LevelBarMode {
    Continuous,
    Discrete,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl ToGlib for LevelBarMode {
    type GlibType = ffi::GtkLevelBarMode;

    fn to_glib(&self) -> ffi::GtkLevelBarMode {
        match *self {
            LevelBarMode::Continuous => ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS,
            LevelBarMode::Discrete => ffi::GTK_LEVEL_BAR_MODE_DISCRETE,
            LevelBarMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl FromGlib<ffi::GtkLevelBarMode> for LevelBarMode {
    fn from_glib(value: ffi::GtkLevelBarMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => LevelBarMode::Continuous,
            1 => LevelBarMode::Discrete,
            value => LevelBarMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum License {
    Unknown,
    Custom,
    Gpl20,
    Gpl30,
    Lgpl21,
    Lgpl30,
    Bsd,
    MitX11,
    Artistic,
    Gpl20Only,
    Gpl30Only,
    Lgpl21Only,
    Lgpl30Only,
    Agpl30,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for License {
    type GlibType = ffi::GtkLicense;

    fn to_glib(&self) -> ffi::GtkLicense {
        match *self {
            License::Unknown => ffi::GTK_LICENSE_UNKNOWN,
            License::Custom => ffi::GTK_LICENSE_CUSTOM,
            License::Gpl20 => ffi::GTK_LICENSE_GPL_2_0,
            License::Gpl30 => ffi::GTK_LICENSE_GPL_3_0,
            License::Lgpl21 => ffi::GTK_LICENSE_LGPL_2_1,
            License::Lgpl30 => ffi::GTK_LICENSE_LGPL_3_0,
            License::Bsd => ffi::GTK_LICENSE_BSD,
            License::MitX11 => ffi::GTK_LICENSE_MIT_X11,
            License::Artistic => ffi::GTK_LICENSE_ARTISTIC,
            License::Gpl20Only => ffi::GTK_LICENSE_GPL_2_0_ONLY,
            License::Gpl30Only => ffi::GTK_LICENSE_GPL_3_0_ONLY,
            License::Lgpl21Only => ffi::GTK_LICENSE_LGPL_2_1_ONLY,
            License::Lgpl30Only => ffi::GTK_LICENSE_LGPL_3_0_ONLY,
            License::Agpl30 => ffi::GTK_LICENSE_AGPL_3_0,
            License::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLicense> for License {
    fn from_glib(value: ffi::GtkLicense) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => License::Unknown,
            1 => License::Custom,
            2 => License::Gpl20,
            3 => License::Gpl30,
            4 => License::Lgpl21,
            5 => License::Lgpl30,
            6 => License::Bsd,
            7 => License::MitX11,
            8 => License::Artistic,
            9 => License::Gpl20Only,
            10 => License::Gpl30Only,
            11 => License::Lgpl21Only,
            12 => License::Lgpl30Only,
            13 => License::Agpl30,
            value => License::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MenuDirectionType {
    Parent,
    Child,
    Next,
    Prev,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for MenuDirectionType {
    type GlibType = ffi::GtkMenuDirectionType;

    fn to_glib(&self) -> ffi::GtkMenuDirectionType {
        match *self {
            MenuDirectionType::Parent => ffi::GTK_MENU_DIR_PARENT,
            MenuDirectionType::Child => ffi::GTK_MENU_DIR_CHILD,
            MenuDirectionType::Next => ffi::GTK_MENU_DIR_NEXT,
            MenuDirectionType::Prev => ffi::GTK_MENU_DIR_PREV,
            MenuDirectionType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMenuDirectionType> for MenuDirectionType {
    fn from_glib(value: ffi::GtkMenuDirectionType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => MenuDirectionType::Parent,
            1 => MenuDirectionType::Child,
            2 => MenuDirectionType::Next,
            3 => MenuDirectionType::Prev,
            value => MenuDirectionType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MessageType {
    Info,
    Warning,
    Question,
    Error,
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for MessageType {
    type GlibType = ffi::GtkMessageType;

    fn to_glib(&self) -> ffi::GtkMessageType {
        match *self {
            MessageType::Info => ffi::GTK_MESSAGE_INFO,
            MessageType::Warning => ffi::GTK_MESSAGE_WARNING,
            MessageType::Question => ffi::GTK_MESSAGE_QUESTION,
            MessageType::Error => ffi::GTK_MESSAGE_ERROR,
            MessageType::Other => ffi::GTK_MESSAGE_OTHER,
            MessageType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMessageType> for MessageType {
    fn from_glib(value: ffi::GtkMessageType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => MessageType::Info,
            1 => MessageType::Warning,
            2 => MessageType::Question,
            3 => MessageType::Error,
            4 => MessageType::Other,
            value => MessageType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MovementStep {
    LogicalPositions,
    VisualPositions,
    Words,
    DisplayLines,
    DisplayLineEnds,
    Paragraphs,
    ParagraphEnds,
    Pages,
    BufferEnds,
    HorizontalPages,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for MovementStep {
    type GlibType = ffi::GtkMovementStep;

    fn to_glib(&self) -> ffi::GtkMovementStep {
        match *self {
            MovementStep::LogicalPositions => ffi::GTK_MOVEMENT_LOGICAL_POSITIONS,
            MovementStep::VisualPositions => ffi::GTK_MOVEMENT_VISUAL_POSITIONS,
            MovementStep::Words => ffi::GTK_MOVEMENT_WORDS,
            MovementStep::DisplayLines => ffi::GTK_MOVEMENT_DISPLAY_LINES,
            MovementStep::DisplayLineEnds => ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS,
            MovementStep::Paragraphs => ffi::GTK_MOVEMENT_PARAGRAPHS,
            MovementStep::ParagraphEnds => ffi::GTK_MOVEMENT_PARAGRAPH_ENDS,
            MovementStep::Pages => ffi::GTK_MOVEMENT_PAGES,
            MovementStep::BufferEnds => ffi::GTK_MOVEMENT_BUFFER_ENDS,
            MovementStep::HorizontalPages => ffi::GTK_MOVEMENT_HORIZONTAL_PAGES,
            MovementStep::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMovementStep> for MovementStep {
    fn from_glib(value: ffi::GtkMovementStep) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => MovementStep::LogicalPositions,
            1 => MovementStep::VisualPositions,
            2 => MovementStep::Words,
            3 => MovementStep::DisplayLines,
            4 => MovementStep::DisplayLineEnds,
            5 => MovementStep::Paragraphs,
            6 => MovementStep::ParagraphEnds,
            7 => MovementStep::Pages,
            8 => MovementStep::BufferEnds,
            9 => MovementStep::HorizontalPages,
            value => MovementStep::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NotebookTab {
    First,
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for NotebookTab {
    type GlibType = ffi::GtkNotebookTab;

    fn to_glib(&self) -> ffi::GtkNotebookTab {
        match *self {
            NotebookTab::First => ffi::GTK_NOTEBOOK_TAB_FIRST,
            NotebookTab::Last => ffi::GTK_NOTEBOOK_TAB_LAST,
            NotebookTab::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNotebookTab> for NotebookTab {
    fn from_glib(value: ffi::GtkNotebookTab) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => NotebookTab::First,
            1 => NotebookTab::Last,
            value => NotebookTab::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NumberUpLayout {
    Lrtb,
    Lrbt,
    Rltb,
    Rlbt,
    Tblr,
    Tbrl,
    Btlr,
    Btrl,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for NumberUpLayout {
    type GlibType = ffi::GtkNumberUpLayout;

    fn to_glib(&self) -> ffi::GtkNumberUpLayout {
        match *self {
            NumberUpLayout::Lrtb => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM,
            NumberUpLayout::Lrbt => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP,
            NumberUpLayout::Rltb => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM,
            NumberUpLayout::Rlbt => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP,
            NumberUpLayout::Tblr => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT,
            NumberUpLayout::Tbrl => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT,
            NumberUpLayout::Btlr => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT,
            NumberUpLayout::Btrl => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT,
            NumberUpLayout::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNumberUpLayout> for NumberUpLayout {
    fn from_glib(value: ffi::GtkNumberUpLayout) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => NumberUpLayout::Lrtb,
            1 => NumberUpLayout::Lrbt,
            2 => NumberUpLayout::Rltb,
            3 => NumberUpLayout::Rlbt,
            4 => NumberUpLayout::Tblr,
            5 => NumberUpLayout::Tbrl,
            6 => NumberUpLayout::Btlr,
            7 => NumberUpLayout::Btrl,
            value => NumberUpLayout::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Orientation {
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for Orientation {
    type GlibType = ffi::GtkOrientation;

    fn to_glib(&self) -> ffi::GtkOrientation {
        match *self {
            Orientation::Horizontal => ffi::GTK_ORIENTATION_HORIZONTAL,
            Orientation::Vertical => ffi::GTK_ORIENTATION_VERTICAL,
            Orientation::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrientation> for Orientation {
    fn from_glib(value: ffi::GtkOrientation) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => Orientation::Horizontal,
            1 => Orientation::Vertical,
            value => Orientation::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PackDirection {
    Ltr,
    Rtl,
    Ttb,
    Btt,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PackDirection {
    type GlibType = ffi::GtkPackDirection;

    fn to_glib(&self) -> ffi::GtkPackDirection {
        match *self {
            PackDirection::Ltr => ffi::GTK_PACK_DIRECTION_LTR,
            PackDirection::Rtl => ffi::GTK_PACK_DIRECTION_RTL,
            PackDirection::Ttb => ffi::GTK_PACK_DIRECTION_TTB,
            PackDirection::Btt => ffi::GTK_PACK_DIRECTION_BTT,
            PackDirection::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackDirection> for PackDirection {
    fn from_glib(value: ffi::GtkPackDirection) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PackDirection::Ltr,
            1 => PackDirection::Rtl,
            2 => PackDirection::Ttb,
            3 => PackDirection::Btt,
            value => PackDirection::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PackType {
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PackType {
    type GlibType = ffi::GtkPackType;

    fn to_glib(&self) -> ffi::GtkPackType {
        match *self {
            PackType::Start => ffi::GTK_PACK_START,
            PackType::End => ffi::GTK_PACK_END,
            PackType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackType> for PackType {
    fn from_glib(value: ffi::GtkPackType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PackType::Start,
            1 => PackType::End,
            value => PackType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PageOrientation {
    Portrait,
    Landscape,
    ReversePortrait,
    ReverseLandscape,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PageOrientation {
    type GlibType = ffi::GtkPageOrientation;

    fn to_glib(&self) -> ffi::GtkPageOrientation {
        match *self {
            PageOrientation::Portrait => ffi::GTK_PAGE_ORIENTATION_PORTRAIT,
            PageOrientation::Landscape => ffi::GTK_PAGE_ORIENTATION_LANDSCAPE,
            PageOrientation::ReversePortrait => ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT,
            PageOrientation::ReverseLandscape => ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE,
            PageOrientation::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageOrientation> for PageOrientation {
    fn from_glib(value: ffi::GtkPageOrientation) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PageOrientation::Portrait,
            1 => PageOrientation::Landscape,
            2 => PageOrientation::ReversePortrait,
            3 => PageOrientation::ReverseLandscape,
            value => PageOrientation::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PageSet {
    All,
    Even,
    Odd,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PageSet {
    type GlibType = ffi::GtkPageSet;

    fn to_glib(&self) -> ffi::GtkPageSet {
        match *self {
            PageSet::All => ffi::GTK_PAGE_SET_ALL,
            PageSet::Even => ffi::GTK_PAGE_SET_EVEN,
            PageSet::Odd => ffi::GTK_PAGE_SET_ODD,
            PageSet::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageSet> for PageSet {
    fn from_glib(value: ffi::GtkPageSet) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PageSet::All,
            1 => PageSet::Even,
            2 => PageSet::Odd,
            value => PageSet::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_14")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PanDirection {
    Left,
    Right,
    Up,
    Down,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl ToGlib for PanDirection {
    type GlibType = ffi::GtkPanDirection;

    fn to_glib(&self) -> ffi::GtkPanDirection {
        match *self {
            PanDirection::Left => ffi::GTK_PAN_DIRECTION_LEFT,
            PanDirection::Right => ffi::GTK_PAN_DIRECTION_RIGHT,
            PanDirection::Up => ffi::GTK_PAN_DIRECTION_UP,
            PanDirection::Down => ffi::GTK_PAN_DIRECTION_DOWN,
            PanDirection::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl FromGlib<ffi::GtkPanDirection> for PanDirection {
    fn from_glib(value: ffi::GtkPanDirection) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PanDirection::Left,
            1 => PanDirection::Right,
            2 => PanDirection::Up,
            3 => PanDirection::Down,
            value => PanDirection::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PolicyType {
    Always,
    Automatic,
    Never,
    External,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PolicyType {
    type GlibType = ffi::GtkPolicyType;

    fn to_glib(&self) -> ffi::GtkPolicyType {
        match *self {
            PolicyType::Always => ffi::GTK_POLICY_ALWAYS,
            PolicyType::Automatic => ffi::GTK_POLICY_AUTOMATIC,
            PolicyType::Never => ffi::GTK_POLICY_NEVER,
            PolicyType::External => ffi::GTK_POLICY_EXTERNAL,
            PolicyType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPolicyType> for PolicyType {
    fn from_glib(value: ffi::GtkPolicyType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PolicyType::Always,
            1 => PolicyType::Automatic,
            2 => PolicyType::Never,
            3 => PolicyType::External,
            value => PolicyType::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_20")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PopoverConstraint {
    None,
    Window,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_20")]
#[doc(hidden)]
impl ToGlib for PopoverConstraint {
    type GlibType = ffi::GtkPopoverConstraint;

    fn to_glib(&self) -> ffi::GtkPopoverConstraint {
        match *self {
            PopoverConstraint::None => ffi::GTK_POPOVER_CONSTRAINT_NONE,
            PopoverConstraint::Window => ffi::GTK_POPOVER_CONSTRAINT_WINDOW,
            PopoverConstraint::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_20")]
#[doc(hidden)]
impl FromGlib<ffi::GtkPopoverConstraint> for PopoverConstraint {
    fn from_glib(value: ffi::GtkPopoverConstraint) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PopoverConstraint::None,
            1 => PopoverConstraint::Window,
            value => PopoverConstraint::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PositionType {
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PositionType {
    type GlibType = ffi::GtkPositionType;

    fn to_glib(&self) -> ffi::GtkPositionType {
        match *self {
            PositionType::Left => ffi::GTK_POS_LEFT,
            PositionType::Right => ffi::GTK_POS_RIGHT,
            PositionType::Top => ffi::GTK_POS_TOP,
            PositionType::Bottom => ffi::GTK_POS_BOTTOM,
            PositionType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPositionType> for PositionType {
    fn from_glib(value: ffi::GtkPositionType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PositionType::Left,
            1 => PositionType::Right,
            2 => PositionType::Top,
            3 => PositionType::Bottom,
            value => PositionType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintDuplex {
    Simplex,
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PrintDuplex {
    type GlibType = ffi::GtkPrintDuplex;

    fn to_glib(&self) -> ffi::GtkPrintDuplex {
        match *self {
            PrintDuplex::Simplex => ffi::GTK_PRINT_DUPLEX_SIMPLEX,
            PrintDuplex::Horizontal => ffi::GTK_PRINT_DUPLEX_HORIZONTAL,
            PrintDuplex::Vertical => ffi::GTK_PRINT_DUPLEX_VERTICAL,
            PrintDuplex::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintDuplex> for PrintDuplex {
    fn from_glib(value: ffi::GtkPrintDuplex) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PrintDuplex::Simplex,
            1 => PrintDuplex::Horizontal,
            2 => PrintDuplex::Vertical,
            value => PrintDuplex::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintError {
    General,
    InternalError,
    Nomem,
    InvalidFile,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = ffi::GtkPrintError;

    fn to_glib(&self) -> ffi::GtkPrintError {
        match *self {
            PrintError::General => ffi::GTK_PRINT_ERROR_GENERAL,
            PrintError::InternalError => ffi::GTK_PRINT_ERROR_INTERNAL_ERROR,
            PrintError::Nomem => ffi::GTK_PRINT_ERROR_NOMEM,
            PrintError::InvalidFile => ffi::GTK_PRINT_ERROR_INVALID_FILE,
            PrintError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintError> for PrintError {
    fn from_glib(value: ffi::GtkPrintError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PrintError::General,
            1 => PrintError::InternalError,
            2 => PrintError::Nomem,
            3 => PrintError::InvalidFile,
            value => PrintError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_print_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(PrintError::General),
            1 => Some(PrintError::InternalError),
            2 => Some(PrintError::Nomem),
            3 => Some(PrintError::InvalidFile),
            value => Some(PrintError::__Unknown(value)),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintPages {
    All,
    Current,
    Ranges,
    Selection,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PrintPages {
    type GlibType = ffi::GtkPrintPages;

    fn to_glib(&self) -> ffi::GtkPrintPages {
        match *self {
            PrintPages::All => ffi::GTK_PRINT_PAGES_ALL,
            PrintPages::Current => ffi::GTK_PRINT_PAGES_CURRENT,
            PrintPages::Ranges => ffi::GTK_PRINT_PAGES_RANGES,
            PrintPages::Selection => ffi::GTK_PRINT_PAGES_SELECTION,
            PrintPages::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintPages> for PrintPages {
    fn from_glib(value: ffi::GtkPrintPages) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PrintPages::All,
            1 => PrintPages::Current,
            2 => PrintPages::Ranges,
            3 => PrintPages::Selection,
            value => PrintPages::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintQuality {
    Low,
    Normal,
    High,
    Draft,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PrintQuality {
    type GlibType = ffi::GtkPrintQuality;

    fn to_glib(&self) -> ffi::GtkPrintQuality {
        match *self {
            PrintQuality::Low => ffi::GTK_PRINT_QUALITY_LOW,
            PrintQuality::Normal => ffi::GTK_PRINT_QUALITY_NORMAL,
            PrintQuality::High => ffi::GTK_PRINT_QUALITY_HIGH,
            PrintQuality::Draft => ffi::GTK_PRINT_QUALITY_DRAFT,
            PrintQuality::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintQuality> for PrintQuality {
    fn from_glib(value: ffi::GtkPrintQuality) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PrintQuality::Low,
            1 => PrintQuality::Normal,
            2 => PrintQuality::High,
            3 => PrintQuality::Draft,
            value => PrintQuality::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_14")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PropagationPhase {
    None,
    Capture,
    Bubble,
    Target,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl ToGlib for PropagationPhase {
    type GlibType = ffi::GtkPropagationPhase;

    fn to_glib(&self) -> ffi::GtkPropagationPhase {
        match *self {
            PropagationPhase::None => ffi::GTK_PHASE_NONE,
            PropagationPhase::Capture => ffi::GTK_PHASE_CAPTURE,
            PropagationPhase::Bubble => ffi::GTK_PHASE_BUBBLE,
            PropagationPhase::Target => ffi::GTK_PHASE_TARGET,
            PropagationPhase::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationPhase> for PropagationPhase {
    fn from_glib(value: ffi::GtkPropagationPhase) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => PropagationPhase::None,
            1 => PropagationPhase::Capture,
            2 => PropagationPhase::Bubble,
            3 => PropagationPhase::Target,
            value => PropagationPhase::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RecentChooserError {
    NotFound,
    InvalidUri,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RecentChooserError {
    type GlibType = ffi::GtkRecentChooserError;

    fn to_glib(&self) -> ffi::GtkRecentChooserError {
        match *self {
            RecentChooserError::NotFound => ffi::GTK_RECENT_CHOOSER_ERROR_NOT_FOUND,
            RecentChooserError::InvalidUri => ffi::GTK_RECENT_CHOOSER_ERROR_INVALID_URI,
            RecentChooserError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentChooserError> for RecentChooserError {
    fn from_glib(value: ffi::GtkRecentChooserError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => RecentChooserError::NotFound,
            1 => RecentChooserError::InvalidUri,
            value => RecentChooserError::__Unknown(value),
        }
    }
}

impl ErrorDomain for RecentChooserError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_recent_chooser_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RecentChooserError::NotFound),
            1 => Some(RecentChooserError::InvalidUri),
            value => Some(RecentChooserError::__Unknown(value)),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RecentManagerError {
    NotFound,
    InvalidUri,
    InvalidEncoding,
    NotRegistered,
    Read,
    Write,
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RecentManagerError {
    type GlibType = ffi::GtkRecentManagerError;

    fn to_glib(&self) -> ffi::GtkRecentManagerError {
        match *self {
            RecentManagerError::NotFound => ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND,
            RecentManagerError::InvalidUri => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI,
            RecentManagerError::InvalidEncoding => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING,
            RecentManagerError::NotRegistered => ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED,
            RecentManagerError::Read => ffi::GTK_RECENT_MANAGER_ERROR_READ,
            RecentManagerError::Write => ffi::GTK_RECENT_MANAGER_ERROR_WRITE,
            RecentManagerError::Unknown => ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN,
            RecentManagerError::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentManagerError> for RecentManagerError {
    fn from_glib(value: ffi::GtkRecentManagerError) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => RecentManagerError::NotFound,
            1 => RecentManagerError::InvalidUri,
            2 => RecentManagerError::InvalidEncoding,
            3 => RecentManagerError::NotRegistered,
            4 => RecentManagerError::Read,
            5 => RecentManagerError::Write,
            6 => RecentManagerError::Unknown,
            value => RecentManagerError::__Unknown(value),
        }
    }
}

impl ErrorDomain for RecentManagerError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_recent_manager_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RecentManagerError::NotFound),
            1 => Some(RecentManagerError::InvalidUri),
            2 => Some(RecentManagerError::InvalidEncoding),
            3 => Some(RecentManagerError::NotRegistered),
            4 => Some(RecentManagerError::Read),
            5 => Some(RecentManagerError::Write),
            6 => Some(RecentManagerError::Unknown),
            value => Some(RecentManagerError::__Unknown(value)),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RecentSortType {
    None,
    Mru,
    Lru,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RecentSortType {
    type GlibType = ffi::GtkRecentSortType;

    fn to_glib(&self) -> ffi::GtkRecentSortType {
        match *self {
            RecentSortType::None => ffi::GTK_RECENT_SORT_NONE,
            RecentSortType::Mru => ffi::GTK_RECENT_SORT_MRU,
            RecentSortType::Lru => ffi::GTK_RECENT_SORT_LRU,
            RecentSortType::Custom => ffi::GTK_RECENT_SORT_CUSTOM,
            RecentSortType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentSortType> for RecentSortType {
    fn from_glib(value: ffi::GtkRecentSortType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => RecentSortType::None,
            1 => RecentSortType::Mru,
            2 => RecentSortType::Lru,
            3 => RecentSortType::Custom,
            value => RecentSortType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ReliefStyle {
    Normal,
    Half,
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ReliefStyle {
    type GlibType = ffi::GtkReliefStyle;

    fn to_glib(&self) -> ffi::GtkReliefStyle {
        match *self {
            ReliefStyle::Normal => ffi::GTK_RELIEF_NORMAL,
            ReliefStyle::Half => ffi::GTK_RELIEF_HALF,
            ReliefStyle::None => ffi::GTK_RELIEF_NONE,
            ReliefStyle::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkReliefStyle> for ReliefStyle {
    fn from_glib(value: ffi::GtkReliefStyle) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ReliefStyle::Normal,
            1 => ReliefStyle::Half,
            2 => ReliefStyle::None,
            value => ReliefStyle::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ResizeMode {
    Parent,
    Queue,
    Immediate,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ResizeMode {
    type GlibType = ffi::GtkResizeMode;

    fn to_glib(&self) -> ffi::GtkResizeMode {
        match *self {
            ResizeMode::Parent => ffi::GTK_RESIZE_PARENT,
            ResizeMode::Queue => ffi::GTK_RESIZE_QUEUE,
            ResizeMode::Immediate => ffi::GTK_RESIZE_IMMEDIATE,
            ResizeMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkResizeMode> for ResizeMode {
    fn from_glib(value: ffi::GtkResizeMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ResizeMode::Parent,
            1 => ResizeMode::Queue,
            2 => ResizeMode::Immediate,
            value => ResizeMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ResponseType {
    None,
    Reject,
    Accept,
    DeleteEvent,
    Ok,
    Cancel,
    Close,
    Yes,
    No,
    Apply,
    Help,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ResponseType {
    type GlibType = ffi::GtkResponseType;

    fn to_glib(&self) -> ffi::GtkResponseType {
        match *self {
            ResponseType::None => ffi::GTK_RESPONSE_NONE,
            ResponseType::Reject => ffi::GTK_RESPONSE_REJECT,
            ResponseType::Accept => ffi::GTK_RESPONSE_ACCEPT,
            ResponseType::DeleteEvent => ffi::GTK_RESPONSE_DELETE_EVENT,
            ResponseType::Ok => ffi::GTK_RESPONSE_OK,
            ResponseType::Cancel => ffi::GTK_RESPONSE_CANCEL,
            ResponseType::Close => ffi::GTK_RESPONSE_CLOSE,
            ResponseType::Yes => ffi::GTK_RESPONSE_YES,
            ResponseType::No => ffi::GTK_RESPONSE_NO,
            ResponseType::Apply => ffi::GTK_RESPONSE_APPLY,
            ResponseType::Help => ffi::GTK_RESPONSE_HELP,
            ResponseType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkResponseType> for ResponseType {
    fn from_glib(value: ffi::GtkResponseType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            -1 => ResponseType::None,
            -2 => ResponseType::Reject,
            -3 => ResponseType::Accept,
            -4 => ResponseType::DeleteEvent,
            -5 => ResponseType::Ok,
            -6 => ResponseType::Cancel,
            -7 => ResponseType::Close,
            -8 => ResponseType::Yes,
            -9 => ResponseType::No,
            -10 => ResponseType::Apply,
            -11 => ResponseType::Help,
            value => ResponseType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RevealerTransitionType {
    None,
    Crossfade,
    SlideRight,
    SlideLeft,
    SlideUp,
    SlideDown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RevealerTransitionType {
    type GlibType = ffi::GtkRevealerTransitionType;

    fn to_glib(&self) -> ffi::GtkRevealerTransitionType {
        match *self {
            RevealerTransitionType::None => ffi::GTK_REVEALER_TRANSITION_TYPE_NONE,
            RevealerTransitionType::Crossfade => ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE,
            RevealerTransitionType::SlideRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT,
            RevealerTransitionType::SlideLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT,
            RevealerTransitionType::SlideUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP,
            RevealerTransitionType::SlideDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN,
            RevealerTransitionType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRevealerTransitionType> for RevealerTransitionType {
    fn from_glib(value: ffi::GtkRevealerTransitionType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => RevealerTransitionType::None,
            1 => RevealerTransitionType::Crossfade,
            2 => RevealerTransitionType::SlideRight,
            3 => RevealerTransitionType::SlideLeft,
            4 => RevealerTransitionType::SlideUp,
            5 => RevealerTransitionType::SlideDown,
            value => RevealerTransitionType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollStep {
    Steps,
    Pages,
    Ends,
    HorizontalSteps,
    HorizontalPages,
    HorizontalEnds,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ScrollStep {
    type GlibType = ffi::GtkScrollStep;

    fn to_glib(&self) -> ffi::GtkScrollStep {
        match *self {
            ScrollStep::Steps => ffi::GTK_SCROLL_STEPS,
            ScrollStep::Pages => ffi::GTK_SCROLL_PAGES,
            ScrollStep::Ends => ffi::GTK_SCROLL_ENDS,
            ScrollStep::HorizontalSteps => ffi::GTK_SCROLL_HORIZONTAL_STEPS,
            ScrollStep::HorizontalPages => ffi::GTK_SCROLL_HORIZONTAL_PAGES,
            ScrollStep::HorizontalEnds => ffi::GTK_SCROLL_HORIZONTAL_ENDS,
            ScrollStep::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollStep> for ScrollStep {
    fn from_glib(value: ffi::GtkScrollStep) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ScrollStep::Steps,
            1 => ScrollStep::Pages,
            2 => ScrollStep::Ends,
            3 => ScrollStep::HorizontalSteps,
            4 => ScrollStep::HorizontalPages,
            5 => ScrollStep::HorizontalEnds,
            value => ScrollStep::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollType {
    None,
    Jump,
    StepBackward,
    StepForward,
    PageBackward,
    PageForward,
    StepUp,
    StepDown,
    PageUp,
    PageDown,
    StepLeft,
    StepRight,
    PageLeft,
    PageRight,
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ScrollType {
    type GlibType = ffi::GtkScrollType;

    fn to_glib(&self) -> ffi::GtkScrollType {
        match *self {
            ScrollType::None => ffi::GTK_SCROLL_NONE,
            ScrollType::Jump => ffi::GTK_SCROLL_JUMP,
            ScrollType::StepBackward => ffi::GTK_SCROLL_STEP_BACKWARD,
            ScrollType::StepForward => ffi::GTK_SCROLL_STEP_FORWARD,
            ScrollType::PageBackward => ffi::GTK_SCROLL_PAGE_BACKWARD,
            ScrollType::PageForward => ffi::GTK_SCROLL_PAGE_FORWARD,
            ScrollType::StepUp => ffi::GTK_SCROLL_STEP_UP,
            ScrollType::StepDown => ffi::GTK_SCROLL_STEP_DOWN,
            ScrollType::PageUp => ffi::GTK_SCROLL_PAGE_UP,
            ScrollType::PageDown => ffi::GTK_SCROLL_PAGE_DOWN,
            ScrollType::StepLeft => ffi::GTK_SCROLL_STEP_LEFT,
            ScrollType::StepRight => ffi::GTK_SCROLL_STEP_RIGHT,
            ScrollType::PageLeft => ffi::GTK_SCROLL_PAGE_LEFT,
            ScrollType::PageRight => ffi::GTK_SCROLL_PAGE_RIGHT,
            ScrollType::Start => ffi::GTK_SCROLL_START,
            ScrollType::End => ffi::GTK_SCROLL_END,
            ScrollType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollType> for ScrollType {
    fn from_glib(value: ffi::GtkScrollType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ScrollType::None,
            1 => ScrollType::Jump,
            2 => ScrollType::StepBackward,
            3 => ScrollType::StepForward,
            4 => ScrollType::PageBackward,
            5 => ScrollType::PageForward,
            6 => ScrollType::StepUp,
            7 => ScrollType::StepDown,
            8 => ScrollType::PageUp,
            9 => ScrollType::PageDown,
            10 => ScrollType::StepLeft,
            11 => ScrollType::StepRight,
            12 => ScrollType::PageLeft,
            13 => ScrollType::PageRight,
            14 => ScrollType::Start,
            15 => ScrollType::End,
            value => ScrollType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollablePolicy {
    Minimum,
    Natural,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ScrollablePolicy {
    type GlibType = ffi::GtkScrollablePolicy;

    fn to_glib(&self) -> ffi::GtkScrollablePolicy {
        match *self {
            ScrollablePolicy::Minimum => ffi::GTK_SCROLL_MINIMUM,
            ScrollablePolicy::Natural => ffi::GTK_SCROLL_NATURAL,
            ScrollablePolicy::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollablePolicy> for ScrollablePolicy {
    fn from_glib(value: ffi::GtkScrollablePolicy) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ScrollablePolicy::Minimum,
            1 => ScrollablePolicy::Natural,
            value => ScrollablePolicy::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SelectionMode {
    None,
    Single,
    Browse,
    Multiple,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SelectionMode {
    type GlibType = ffi::GtkSelectionMode;

    fn to_glib(&self) -> ffi::GtkSelectionMode {
        match *self {
            SelectionMode::None => ffi::GTK_SELECTION_NONE,
            SelectionMode::Single => ffi::GTK_SELECTION_SINGLE,
            SelectionMode::Browse => ffi::GTK_SELECTION_BROWSE,
            SelectionMode::Multiple => ffi::GTK_SELECTION_MULTIPLE,
            SelectionMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSelectionMode> for SelectionMode {
    fn from_glib(value: ffi::GtkSelectionMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SelectionMode::None,
            1 => SelectionMode::Single,
            2 => SelectionMode::Browse,
            3 => SelectionMode::Multiple,
            value => SelectionMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SensitivityType {
    Auto,
    On,
    Off,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SensitivityType {
    type GlibType = ffi::GtkSensitivityType;

    fn to_glib(&self) -> ffi::GtkSensitivityType {
        match *self {
            SensitivityType::Auto => ffi::GTK_SENSITIVITY_AUTO,
            SensitivityType::On => ffi::GTK_SENSITIVITY_ON,
            SensitivityType::Off => ffi::GTK_SENSITIVITY_OFF,
            SensitivityType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSensitivityType> for SensitivityType {
    fn from_glib(value: ffi::GtkSensitivityType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SensitivityType::Auto,
            1 => SensitivityType::On,
            2 => SensitivityType::Off,
            value => SensitivityType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ShadowType {
    None,
    In,
    Out,
    EtchedIn,
    EtchedOut,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ShadowType {
    type GlibType = ffi::GtkShadowType;

    fn to_glib(&self) -> ffi::GtkShadowType {
        match *self {
            ShadowType::None => ffi::GTK_SHADOW_NONE,
            ShadowType::In => ffi::GTK_SHADOW_IN,
            ShadowType::Out => ffi::GTK_SHADOW_OUT,
            ShadowType::EtchedIn => ffi::GTK_SHADOW_ETCHED_IN,
            ShadowType::EtchedOut => ffi::GTK_SHADOW_ETCHED_OUT,
            ShadowType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShadowType> for ShadowType {
    fn from_glib(value: ffi::GtkShadowType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ShadowType::None,
            1 => ShadowType::In,
            2 => ShadowType::Out,
            3 => ShadowType::EtchedIn,
            4 => ShadowType::EtchedOut,
            value => ShadowType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SizeGroupMode {
    None,
    Horizontal,
    Vertical,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SizeGroupMode {
    type GlibType = ffi::GtkSizeGroupMode;

    fn to_glib(&self) -> ffi::GtkSizeGroupMode {
        match *self {
            SizeGroupMode::None => ffi::GTK_SIZE_GROUP_NONE,
            SizeGroupMode::Horizontal => ffi::GTK_SIZE_GROUP_HORIZONTAL,
            SizeGroupMode::Vertical => ffi::GTK_SIZE_GROUP_VERTICAL,
            SizeGroupMode::Both => ffi::GTK_SIZE_GROUP_BOTH,
            SizeGroupMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeGroupMode> for SizeGroupMode {
    fn from_glib(value: ffi::GtkSizeGroupMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SizeGroupMode::None,
            1 => SizeGroupMode::Horizontal,
            2 => SizeGroupMode::Vertical,
            3 => SizeGroupMode::Both,
            value => SizeGroupMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SizeRequestMode {
    HeightForWidth,
    WidthForHeight,
    ConstantSize,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SizeRequestMode {
    type GlibType = ffi::GtkSizeRequestMode;

    fn to_glib(&self) -> ffi::GtkSizeRequestMode {
        match *self {
            SizeRequestMode::HeightForWidth => ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH,
            SizeRequestMode::WidthForHeight => ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT,
            SizeRequestMode::ConstantSize => ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE,
            SizeRequestMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeRequestMode> for SizeRequestMode {
    fn from_glib(value: ffi::GtkSizeRequestMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SizeRequestMode::HeightForWidth,
            1 => SizeRequestMode::WidthForHeight,
            2 => SizeRequestMode::ConstantSize,
            value => SizeRequestMode::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SortType {
    Ascending,
    Descending,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SortType {
    type GlibType = ffi::GtkSortType;

    fn to_glib(&self) -> ffi::GtkSortType {
        match *self {
            SortType::Ascending => ffi::GTK_SORT_ASCENDING,
            SortType::Descending => ffi::GTK_SORT_DESCENDING,
            SortType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSortType> for SortType {
    fn from_glib(value: ffi::GtkSortType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SortType::Ascending,
            1 => SortType::Descending,
            value => SortType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SpinButtonUpdatePolicy {
    Always,
    IfValid,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SpinButtonUpdatePolicy {
    type GlibType = ffi::GtkSpinButtonUpdatePolicy;

    fn to_glib(&self) -> ffi::GtkSpinButtonUpdatePolicy {
        match *self {
            SpinButtonUpdatePolicy::Always => ffi::GTK_UPDATE_ALWAYS,
            SpinButtonUpdatePolicy::IfValid => ffi::GTK_UPDATE_IF_VALID,
            SpinButtonUpdatePolicy::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinButtonUpdatePolicy> for SpinButtonUpdatePolicy {
    fn from_glib(value: ffi::GtkSpinButtonUpdatePolicy) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SpinButtonUpdatePolicy::Always,
            1 => SpinButtonUpdatePolicy::IfValid,
            value => SpinButtonUpdatePolicy::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SpinType {
    StepForward,
    StepBackward,
    PageForward,
    PageBackward,
    Home,
    End,
    UserDefined,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SpinType {
    type GlibType = ffi::GtkSpinType;

    fn to_glib(&self) -> ffi::GtkSpinType {
        match *self {
            SpinType::StepForward => ffi::GTK_SPIN_STEP_FORWARD,
            SpinType::StepBackward => ffi::GTK_SPIN_STEP_BACKWARD,
            SpinType::PageForward => ffi::GTK_SPIN_PAGE_FORWARD,
            SpinType::PageBackward => ffi::GTK_SPIN_PAGE_BACKWARD,
            SpinType::Home => ffi::GTK_SPIN_HOME,
            SpinType::End => ffi::GTK_SPIN_END,
            SpinType::UserDefined => ffi::GTK_SPIN_USER_DEFINED,
            SpinType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinType> for SpinType {
    fn from_glib(value: ffi::GtkSpinType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => SpinType::StepForward,
            1 => SpinType::StepBackward,
            2 => SpinType::PageForward,
            3 => SpinType::PageBackward,
            4 => SpinType::Home,
            5 => SpinType::End,
            6 => SpinType::UserDefined,
            value => SpinType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum StackTransitionType {
    None,
    Crossfade,
    SlideRight,
    SlideLeft,
    SlideUp,
    SlideDown,
    SlideLeftRight,
    SlideUpDown,
    OverUp,
    OverDown,
    OverLeft,
    OverRight,
    UnderUp,
    UnderDown,
    UnderLeft,
    UnderRight,
    OverUpDown,
    OverDownUp,
    OverLeftRight,
    OverRightLeft,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for StackTransitionType {
    type GlibType = ffi::GtkStackTransitionType;

    fn to_glib(&self) -> ffi::GtkStackTransitionType {
        match *self {
            StackTransitionType::None => ffi::GTK_STACK_TRANSITION_TYPE_NONE,
            StackTransitionType::Crossfade => ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE,
            StackTransitionType::SlideRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT,
            StackTransitionType::SlideLeft => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT,
            StackTransitionType::SlideUp => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP,
            StackTransitionType::SlideDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN,
            StackTransitionType::SlideLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT,
            StackTransitionType::SlideUpDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN,
            StackTransitionType::OverUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP,
            StackTransitionType::OverDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN,
            StackTransitionType::OverLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT,
            StackTransitionType::OverRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT,
            StackTransitionType::UnderUp => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP,
            StackTransitionType::UnderDown => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN,
            StackTransitionType::UnderLeft => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT,
            StackTransitionType::UnderRight => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT,
            StackTransitionType::OverUpDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN,
            StackTransitionType::OverDownUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP,
            StackTransitionType::OverLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT,
            StackTransitionType::OverRightLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT,
            StackTransitionType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStackTransitionType> for StackTransitionType {
    fn from_glib(value: ffi::GtkStackTransitionType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => StackTransitionType::None,
            1 => StackTransitionType::Crossfade,
            2 => StackTransitionType::SlideRight,
            3 => StackTransitionType::SlideLeft,
            4 => StackTransitionType::SlideUp,
            5 => StackTransitionType::SlideDown,
            6 => StackTransitionType::SlideLeftRight,
            7 => StackTransitionType::SlideUpDown,
            8 => StackTransitionType::OverUp,
            9 => StackTransitionType::OverDown,
            10 => StackTransitionType::OverLeft,
            11 => StackTransitionType::OverRight,
            12 => StackTransitionType::UnderUp,
            13 => StackTransitionType::UnderDown,
            14 => StackTransitionType::UnderLeft,
            15 => StackTransitionType::UnderRight,
            16 => StackTransitionType::OverUpDown,
            17 => StackTransitionType::OverDownUp,
            18 => StackTransitionType::OverLeftRight,
            19 => StackTransitionType::OverRightLeft,
            value => StackTransitionType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum StateType {
    Normal,
    Active,
    Prelight,
    Selected,
    Insensitive,
    Inconsistent,
    Focused,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for StateType {
    type GlibType = ffi::GtkStateType;

    fn to_glib(&self) -> ffi::GtkStateType {
        match *self {
            StateType::Normal => ffi::GTK_STATE_NORMAL,
            StateType::Active => ffi::GTK_STATE_ACTIVE,
            StateType::Prelight => ffi::GTK_STATE_PRELIGHT,
            StateType::Selected => ffi::GTK_STATE_SELECTED,
            StateType::Insensitive => ffi::GTK_STATE_INSENSITIVE,
            StateType::Inconsistent => ffi::GTK_STATE_INCONSISTENT,
            StateType::Focused => ffi::GTK_STATE_FOCUSED,
            StateType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStateType> for StateType {
    fn from_glib(value: ffi::GtkStateType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => StateType::Normal,
            1 => StateType::Active,
            2 => StateType::Prelight,
            3 => StateType::Selected,
            4 => StateType::Insensitive,
            5 => StateType::Inconsistent,
            6 => StateType::Focused,
            value => StateType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TextDirection {
    None,
    Ltr,
    Rtl,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TextDirection {
    type GlibType = ffi::GtkTextDirection;

    fn to_glib(&self) -> ffi::GtkTextDirection {
        match *self {
            TextDirection::None => ffi::GTK_TEXT_DIR_NONE,
            TextDirection::Ltr => ffi::GTK_TEXT_DIR_LTR,
            TextDirection::Rtl => ffi::GTK_TEXT_DIR_RTL,
            TextDirection::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextDirection> for TextDirection {
    fn from_glib(value: ffi::GtkTextDirection) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => TextDirection::None,
            1 => TextDirection::Ltr,
            2 => TextDirection::Rtl,
            value => TextDirection::__Unknown(value),
        }
    }
}

#[cfg(feature = "v3_16")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TextExtendSelection {
    Word,
    Line,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v3_16")]
#[doc(hidden)]
impl ToGlib for TextExtendSelection {
    type GlibType = ffi::GtkTextExtendSelection;

    fn to_glib(&self) -> ffi::GtkTextExtendSelection {
        match *self {
            TextExtendSelection::Word => ffi::GTK_TEXT_EXTEND_SELECTION_WORD,
            TextExtendSelection::Line => ffi::GTK_TEXT_EXTEND_SELECTION_LINE,
            TextExtendSelection::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[cfg(feature = "v3_16")]
#[doc(hidden)]
impl FromGlib<ffi::GtkTextExtendSelection> for TextExtendSelection {
    fn from_glib(value: ffi::GtkTextExtendSelection) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => TextExtendSelection::Word,
            1 => TextExtendSelection::Line,
            value => TextExtendSelection::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TextWindowType {
    Private,
    Widget,
    Text,
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TextWindowType {
    type GlibType = ffi::GtkTextWindowType;

    fn to_glib(&self) -> ffi::GtkTextWindowType {
        match *self {
            TextWindowType::Private => ffi::GTK_TEXT_WINDOW_PRIVATE,
            TextWindowType::Widget => ffi::GTK_TEXT_WINDOW_WIDGET,
            TextWindowType::Text => ffi::GTK_TEXT_WINDOW_TEXT,
            TextWindowType::Left => ffi::GTK_TEXT_WINDOW_LEFT,
            TextWindowType::Right => ffi::GTK_TEXT_WINDOW_RIGHT,
            TextWindowType::Top => ffi::GTK_TEXT_WINDOW_TOP,
            TextWindowType::Bottom => ffi::GTK_TEXT_WINDOW_BOTTOM,
            TextWindowType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextWindowType> for TextWindowType {
    fn from_glib(value: ffi::GtkTextWindowType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => TextWindowType::Private,
            1 => TextWindowType::Widget,
            2 => TextWindowType::Text,
            3 => TextWindowType::Left,
            4 => TextWindowType::Right,
            5 => TextWindowType::Top,
            6 => TextWindowType::Bottom,
            value => TextWindowType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ToolbarStyle {
    Icons,
    Text,
    Both,
    BothHoriz,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ToolbarStyle {
    type GlibType = ffi::GtkToolbarStyle;

    fn to_glib(&self) -> ffi::GtkToolbarStyle {
        match *self {
            ToolbarStyle::Icons => ffi::GTK_TOOLBAR_ICONS,
            ToolbarStyle::Text => ffi::GTK_TOOLBAR_TEXT,
            ToolbarStyle::Both => ffi::GTK_TOOLBAR_BOTH,
            ToolbarStyle::BothHoriz => ffi::GTK_TOOLBAR_BOTH_HORIZ,
            ToolbarStyle::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkToolbarStyle> for ToolbarStyle {
    fn from_glib(value: ffi::GtkToolbarStyle) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => ToolbarStyle::Icons,
            1 => ToolbarStyle::Text,
            2 => ToolbarStyle::Both,
            3 => ToolbarStyle::BothHoriz,
            value => ToolbarStyle::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TreeViewColumnSizing {
    GrowOnly,
    Autosize,
    Fixed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TreeViewColumnSizing {
    type GlibType = ffi::GtkTreeViewColumnSizing;

    fn to_glib(&self) -> ffi::GtkTreeViewColumnSizing {
        match *self {
            TreeViewColumnSizing::GrowOnly => ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY,
            TreeViewColumnSizing::Autosize => ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE,
            TreeViewColumnSizing::Fixed => ffi::GTK_TREE_VIEW_COLUMN_FIXED,
            TreeViewColumnSizing::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewColumnSizing> for TreeViewColumnSizing {
    fn from_glib(value: ffi::GtkTreeViewColumnSizing) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => TreeViewColumnSizing::GrowOnly,
            1 => TreeViewColumnSizing::Autosize,
            2 => TreeViewColumnSizing::Fixed,
            value => TreeViewColumnSizing::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TreeViewDropPosition {
    Before,
    After,
    IntoOrBefore,
    IntoOrAfter,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TreeViewDropPosition {
    type GlibType = ffi::GtkTreeViewDropPosition;

    fn to_glib(&self) -> ffi::GtkTreeViewDropPosition {
        match *self {
            TreeViewDropPosition::Before => ffi::GTK_TREE_VIEW_DROP_BEFORE,
            TreeViewDropPosition::After => ffi::GTK_TREE_VIEW_DROP_AFTER,
            TreeViewDropPosition::IntoOrBefore => ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE,
            TreeViewDropPosition::IntoOrAfter => ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER,
            TreeViewDropPosition::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewDropPosition> for TreeViewDropPosition {
    fn from_glib(value: ffi::GtkTreeViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => TreeViewDropPosition::Before,
            1 => TreeViewDropPosition::After,
            2 => TreeViewDropPosition::IntoOrBefore,
            3 => TreeViewDropPosition::IntoOrAfter,
            value => TreeViewDropPosition::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TreeViewGridLines {
    None,
    Horizontal,
    Vertical,
    Both,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TreeViewGridLines {
    type GlibType = ffi::GtkTreeViewGridLines;

    fn to_glib(&self) -> ffi::GtkTreeViewGridLines {
        match *self {
            TreeViewGridLines::None => ffi::GTK_TREE_VIEW_GRID_LINES_NONE,
            TreeViewGridLines::Horizontal => ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL,
            TreeViewGridLines::Vertical => ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL,
            TreeViewGridLines::Both => ffi::GTK_TREE_VIEW_GRID_LINES_BOTH,
            TreeViewGridLines::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewGridLines> for TreeViewGridLines {
    fn from_glib(value: ffi::GtkTreeViewGridLines) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => TreeViewGridLines::None,
            1 => TreeViewGridLines::Horizontal,
            2 => TreeViewGridLines::Vertical,
            3 => TreeViewGridLines::Both,
            value => TreeViewGridLines::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Unit {
    None,
    Points,
    Inch,
    Mm,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for Unit {
    type GlibType = ffi::GtkUnit;

    fn to_glib(&self) -> ffi::GtkUnit {
        match *self {
            Unit::None => ffi::GTK_UNIT_NONE,
            Unit::Points => ffi::GTK_UNIT_POINTS,
            Unit::Inch => ffi::GTK_UNIT_INCH,
            Unit::Mm => ffi::GTK_UNIT_MM,
            Unit::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkUnit> for Unit {
    fn from_glib(value: ffi::GtkUnit) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => Unit::None,
            1 => Unit::Points,
            2 => Unit::Inch,
            3 => Unit::Mm,
            value => Unit::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WidgetHelpType {
    Tooltip,
    WhatsThis,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WidgetHelpType {
    type GlibType = ffi::GtkWidgetHelpType;

    fn to_glib(&self) -> ffi::GtkWidgetHelpType {
        match *self {
            WidgetHelpType::Tooltip => ffi::GTK_WIDGET_HELP_TOOLTIP,
            WidgetHelpType::WhatsThis => ffi::GTK_WIDGET_HELP_WHATS_THIS,
            WidgetHelpType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWidgetHelpType> for WidgetHelpType {
    fn from_glib(value: ffi::GtkWidgetHelpType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => WidgetHelpType::Tooltip,
            1 => WidgetHelpType::WhatsThis,
            value => WidgetHelpType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowPosition {
    None,
    Center,
    Mouse,
    CenterAlways,
    CenterOnParent,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WindowPosition {
    type GlibType = ffi::GtkWindowPosition;

    fn to_glib(&self) -> ffi::GtkWindowPosition {
        match *self {
            WindowPosition::None => ffi::GTK_WIN_POS_NONE,
            WindowPosition::Center => ffi::GTK_WIN_POS_CENTER,
            WindowPosition::Mouse => ffi::GTK_WIN_POS_MOUSE,
            WindowPosition::CenterAlways => ffi::GTK_WIN_POS_CENTER_ALWAYS,
            WindowPosition::CenterOnParent => ffi::GTK_WIN_POS_CENTER_ON_PARENT,
            WindowPosition::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWindowPosition> for WindowPosition {
    fn from_glib(value: ffi::GtkWindowPosition) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => WindowPosition::None,
            1 => WindowPosition::Center,
            2 => WindowPosition::Mouse,
            3 => WindowPosition::CenterAlways,
            4 => WindowPosition::CenterOnParent,
            value => WindowPosition::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowType {
    Toplevel,
    Popup,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WindowType {
    type GlibType = ffi::GtkWindowType;

    fn to_glib(&self) -> ffi::GtkWindowType {
        match *self {
            WindowType::Toplevel => ffi::GTK_WINDOW_TOPLEVEL,
            WindowType::Popup => ffi::GTK_WINDOW_POPUP,
            WindowType::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWindowType> for WindowType {
    fn from_glib(value: ffi::GtkWindowType) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => WindowType::Toplevel,
            1 => WindowType::Popup,
            value => WindowType::__Unknown(value),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WrapMode {
    None,
    Char,
    Word,
    WordChar,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WrapMode {
    type GlibType = ffi::GtkWrapMode;

    fn to_glib(&self) -> ffi::GtkWrapMode {
        match *self {
            WrapMode::None => ffi::GTK_WRAP_NONE,
            WrapMode::Char => ffi::GTK_WRAP_CHAR,
            WrapMode::Word => ffi::GTK_WRAP_WORD,
            WrapMode::WordChar => ffi::GTK_WRAP_WORD_CHAR,
            WrapMode::__Unknown(value) => unsafe{std::mem::transmute(value)}
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWrapMode> for WrapMode {
    fn from_glib(value: ffi::GtkWrapMode) -> Self {
        skip_assert_initialized!();
        match value as i32 {
            0 => WrapMode::None,
            1 => WrapMode::Char,
            2 => WrapMode::Word,
            3 => WrapMode::WordChar,
            value => WrapMode::__Unknown(value),
        }
    }
}

